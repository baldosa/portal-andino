#!/usr/bin/env bash

ProgName=$(basename $0);
app_name="portal";
db_name="db";
APP_DIR=/etc/andino
BACKUPS_DIR="$APP_DIR/backups"
COMPOSE_FILE="$APP_DIR/docker-compose.yml"

info() {
    echo -e "\e[38;5;75m\e[1m[ INFO ]\e[0m $1";
}

success() {
    echo -e "\e[38;5;76m\e[1m[ SUCCESS ]\e[0m $1";   
}

error() {
    echo -e "\e[1m\e[31m[ ERROR ]\e[0m $1";
}

sub_help(){
    echo "Uso: $ProgName <subcomando>"
    echo "Subcomandos:"
    echo "  Generales:"
    echo "    up [servicios]            Levantar la aplicacion (Regenerar si es necesario)"
    echo "    ps [-aq]                  Tabla de ejecucion actual"
    echo "    exec [comandos]           Ejecutar un comando en la aplicacion de andino"
    echo "    restart [servicios]       Reiniciar los servicios"
    echo "    stop [servicios]          Detener los servicios"
    echo "    down                      Borrar los datos de la aplicación"
    echo "    explode                   Borrar la aplicación"
    echo "    post_update               Correr comando necesarios después de una actualización"

    echo "  Ckan:"
    echo "    paster                    Correr comando con paster en la aplicación"

    echo "  Usuarios:"
    echo "    add_admin [username]      Crear un usuario Admin dentro de andino"
    echo "    add_user  [username]      Crear un usuario dentro de andino"
    echo "    delete_user [username]    Borrar un usuario dentro de andino"
    echo "    view_user [username]      Ver un usuario dentro de andino"
    echo "    chpass    [username]      Cambiar la contraseña de un usuario dentro de andino"
    echo "    list_users                Listar usuarios dentro de andino"

    echo "  Datos y entorno:"
    echo "    find_volumes              Encontrar los volumentes de docker"
    echo "    show_ips                  Ver las IPs de los contenedores"
    echo "    show_envs                 Ver las variables de entorno de los contenedores"
    echo "    exec_db [comandos]        Ejecutar comando dentro de la base de datos"
    echo "    exec_pqsl                 Accesder a psql dentro de la base de datos"

    echo "  Backups:"
    echo "    backup_db                 Crear un backup de la base de datos. "
    echo "    backup_fs                 Crear un backup de los archivos de andino. "
    echo "    backup_conf                 Crear un backup de los archivos de configuracion. "

    echo ""
    echo "Variables de entorno:"
    echo "    Algunas variables modifican el comportamiento de los comandos"
    echo "    NO_CONFIRM: Pasa el parametro '-T' a docker-compose exec."
    echo "      Útil para correr comandos sin una terminal."
    echo ""
}

check_permissions() {
    if [[ $(/usr/bin/id -u) -ne 0 ]]; then
      error "Se necesitan permisos de root (sudo)";
      exit 1;
    fi
}

sub_command() {
    # cd'ing is required because docker-compose.yml requires that the .env file is in the _working directory_
    local _command="docker-compose -f $COMPOSE_FILE $@;"
    bash -c "cd $APP_DIR && $_command";
}

## General

sub_up(){
    sub_command up -d $@;
}

sub_ps() {
    sub_command ps $@;
}

sub_exec_on() {
    # La variable NO_CONFIRM es usada para evitar la interaccion del usuario
    local _command="sub_command exec ";
    if [ -n "$NO_CONFIRM" ]; then
        # Desactivando uso de pseudo-tty
        _command="$_command -T"
    fi
    $_command $@;

}

sub_exec() {
    sub_exec_on "$app_name" $@;
}

sub_restart() {
    sub_command restart $@;
}

sub_stop(){
    sub_command stop $@;
}

sub_down(){
    sub_command down -v;
}

sub_explode() {
    check_permissions;
    sub_down;
    rm "$APP_DIR" -rf;
    rm /usr/local/bin/andino-ctl -rf;
}

sub_post_update() {
    # This commands must be idempotent
    # Noop
    info "Ok"
}

### Ckan

sub_paster(){
    sub_exec /etc/ckan_init.d/paster.sh $@;
}

### Usuarios

sub_add_admin() {
    sub_exec /etc/ckan_init.d/add_admin.sh $@;
}

sub_add_user() {
    sub_paster --plugin=ckan user add $@;
}

sub_delete_user() {
    sub_paster --plugin=ckan user remove $@;
}

sub_view_user() {
    sub_paster --plugin=ckan user $@;
}

sub_chpass() {
    sub_paster --plugin=ckan user setpass $@;
}

sub_list_users() {
    sub_paster --plugin=ckan user list;
}

### Datos & entorno

sub_find_volumes(){
    sub_ps -q portal solr db | xargs -n 1 | while read container; do docker inspect -f ' {{.Name}}: {{range .Mounts}}{{.Source}}: {{.Destination}}  {{end}} ' $container; done
}

sub_show_ips(){
    sub_ps -q portal solr db | xargs -n 1 | while read container; do docker inspect -f '{{.Name}}: {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' $container; done
}

sub_show_envs(){
    sub_ps -q portal solr db | xargs -n 1 | while read container; do docker inspect -f '{{range $index, $value := .Config.Env}}export {{$value}}{{println}}{{end}}' $container; done
}

sub_exec_db(){
    sub_exec_on "$db_name" $@;
}

sub_exec_psql(){
    sub_exec_db psql -U postgres $@;
}

### Backups

sub_backup_db() {
    check_permissions
    local dest="$BACKUPS_DIR/database"
    mkdir -p "$dest"
    info "Creando backup en $dest"

    local today=`date +%Y-%m-%d.%H:%M:%S`
    local filename="andino-backup-$today.gz"
    local container="$(sub_ps -q $db_name)"

    # Creo un directorio temporal y defino dónde generaré el backup
    local backupdir=$(mktemp -d)
    local backupfile="$backupdir/$filename"

    # Exporto la base de datos
    info "Iniciando backup de la base de datos en $backupfile"

    # This is required!
    export NO_CONFIRM=1;
    sub_exec_db pg_dumpall -c -U postgres | gzip > "$backupfile"
    unset NO_CONFIRM;
    info "Finalizando backup de la base de datos. Moviendo a $dest"
    # Copio el archivo al directorio actual y borro el original
    # Podría reemplazar $PWD con mi directorio de backups, como /etc/portal/backups
    mv "$backupfile" "$dest"
    success "Backup terminado. "
}

sub_backup_fs() {
    check_permissions
    local dest="$BACKUPS_DIR/files"
    mkdir -p "$dest"
    local app_container="$(sub_ps -q $app_name)"

    local today=`date +%Y-%m-%d.%H:%M:%S`
    # Obtengo el path al almacenamiento del volumen
    local andino_fs="$(docker inspect --format '{{ range .Mounts }}{{ if eq .Destination "/var/lib/ckan" }}{{ .Source }}{{ end }}{{ end }}' $app_container)"
    local backup_file="$dest/andino-fs-data-$today.tar.gz"
    # Creo un tar.gz con la info.
    info "Iniciando backup de los archivos. Destino: $backup_file"
    tar -C "$(dirname "$andino_fs")" -zcvf "$backup_file" "$(basename "$andino_fs")"
    success "Backup terminado. "
}

sub_backup_conf() {
    check_permissions
    local dest="$BACKUPS_DIR/files"
    mkdir -p "$dest"
    local app_container="$(sub_ps -q $app_name)"
    local today=`date +%Y-%m-%d.%H:%M:%S`

    # Obtengo el path al almacenamiento del volumen
    local andino_conf="$(docker inspect --format '{{ range .Mounts }}{{ if eq .Destination "/etc/ckan/default" }}{{ .Source }}{{ end }}{{ end }}' $app_container)"
    local backup_file="$dest/andino-config-data-$today.tar.gz"
    # Creo un tar.gz con la info.
    info "Iniciando backup de los archivos. Destino: $backup_file"
    tar -C "$(dirname "$andino_conf")" -zcvf "$backup_file" "$(basename "$andino_conf")"
    success "Backup terminado. "
}

sub_backup_all_files() {
    sub_backup_db;
    sub_backup_fs;
    sub_backup_conf;
}

subcommand=$1
case $subcommand in
    "" | "-h" | "--help")
        sub_help
        ;;
    *)
        shift
        sub_${subcommand} $@
        rc=$?
        if [ $rc = 127 ]; then
            echo "Error: '$subcommand' no es un subcomando conocido." >&2
            echo "       Corre '$ProgName --help' para listar los comandos." >&2
            exit 1;
        fi
        if [ $rc != 0 ]; then
            exit $rc;
        fi
esac
